<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>The mice imputation flow</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="mice_flow_files/libs/clipboard/clipboard.min.js"></script>
<script src="mice_flow_files/libs/quarto-html/quarto.js"></script>
<script src="mice_flow_files/libs/quarto-html/popper.min.js"></script>
<script src="mice_flow_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="mice_flow_files/libs/quarto-html/anchor.min.js"></script>
<link href="mice_flow_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="mice_flow_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="mice_flow_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="mice_flow_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="mice_flow_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#tldr" id="toc-tldr" class="nav-link active" data-scroll-target="#tldr"><span class="header-section-number">1</span> tl;dr</a>
  <ul class="collapse">
  <li><a href="#generating-imputations" id="toc-generating-imputations" class="nav-link" data-scroll-target="#generating-imputations"><span class="header-section-number">1.1</span> Generating imputations</a></li>
  <li><a href="#presentation-of-imputed-data" id="toc-presentation-of-imputed-data" class="nav-link" data-scroll-target="#presentation-of-imputed-data"><span class="header-section-number">1.2</span> Presentation of imputed data</a></li>
  <li><a href="#analyzing-imputed-data" id="toc-analyzing-imputed-data" class="nav-link" data-scroll-target="#analyzing-imputed-data"><span class="header-section-number">1.3</span> Analyzing imputed data</a></li>
  </ul></li>
  <li><a href="#introduction-to-mice" id="toc-introduction-to-mice" class="nav-link" data-scroll-target="#introduction-to-mice"><span class="header-section-number">2</span> Introduction to <code>mice</code></a></li>
  <li><a href="#aim-of-this-flow" id="toc-aim-of-this-flow" class="nav-link" data-scroll-target="#aim-of-this-flow"><span class="header-section-number">3</span> Aim of this flow</a></li>
  <li><a href="#imputation" id="toc-imputation" class="nav-link" data-scroll-target="#imputation"><span class="header-section-number">4</span> Imputation</a>
  <ul class="collapse">
  <li><a href="#imputation-procedure" id="toc-imputation-procedure" class="nav-link" data-scroll-target="#imputation-procedure"><span class="header-section-number">4.1</span> Imputation procedure</a>
  <ul class="collapse">
  <li><a href="#joint-model-imputation" id="toc-joint-model-imputation" class="nav-link" data-scroll-target="#joint-model-imputation"><span class="header-section-number">4.1.1</span> Joint model imputation</a></li>
  <li><a href="#fully-conditional-specification" id="toc-fully-conditional-specification" class="nav-link" data-scroll-target="#fully-conditional-specification"><span class="header-section-number">4.1.2</span> Fully conditional specification</a></li>
  <li><a href="#hybrids-of-jm-and-fcs" id="toc-hybrids-of-jm-and-fcs" class="nav-link" data-scroll-target="#hybrids-of-jm-and-fcs"><span class="header-section-number">4.1.3</span> Hybrids of JM and FCS</a></li>
  </ul></li>
  <li><a href="#selecting-predictors" id="toc-selecting-predictors" class="nav-link" data-scroll-target="#selecting-predictors"><span class="header-section-number">4.2</span> Selecting predictors</a></li>
  <li><a href="#selecting-an-imputation-method" id="toc-selecting-an-imputation-method" class="nav-link" data-scroll-target="#selecting-an-imputation-method"><span class="header-section-number">4.3</span> Selecting an imputation method</a></li>
  <li><a href="#determining-the-visit-sequence" id="toc-determining-the-visit-sequence" class="nav-link" data-scroll-target="#determining-the-visit-sequence"><span class="header-section-number">4.4</span> Determining the visit sequence</a></li>
  </ul></li>
  <li><a href="#analysis-of-imputed-data" id="toc-analysis-of-imputed-data" class="nav-link" data-scroll-target="#analysis-of-imputed-data"><span class="header-section-number">5</span> Analysis of imputed data</a></li>
  <li><a href="#evaluation-of-algorithmic-convergence" id="toc-evaluation-of-algorithmic-convergence" class="nav-link" data-scroll-target="#evaluation-of-algorithmic-convergence"><span class="header-section-number">6</span> Evaluation of algorithmic convergence</a></li>
  <li><a href="#evaluation-of-the-imputations" id="toc-evaluation-of-the-imputations" class="nav-link" data-scroll-target="#evaluation-of-the-imputations"><span class="header-section-number">7</span> Evaluation of the imputations</a></li>
  <li><a href="#sec-crucial" id="toc-sec-crucial" class="nav-link" data-scroll-target="#sec-crucial"><span class="header-section-number">8</span> What JASP output is crucial?</a>
  <ul class="collapse">
  <li><a href="#linear-regression" id="toc-linear-regression" class="nav-link" data-scroll-target="#linear-regression"><span class="header-section-number">8.1</span> Linear regression</a></li>
  <li><a href="#pooling-regression-output" id="toc-pooling-regression-output" class="nav-link" data-scroll-target="#pooling-regression-output"><span class="header-section-number">8.2</span> Pooling regression output</a>
  <ul class="collapse">
  <li><a href="#coefficients-and-their-tests" id="toc-coefficients-and-their-tests" class="nav-link" data-scroll-target="#coefficients-and-their-tests"><span class="header-section-number">8.2.1</span> Coefficients and their tests</a></li>
  <li><a href="#seperate-output-per-imputed-data-set" id="toc-seperate-output-per-imputed-data-set" class="nav-link" data-scroll-target="#seperate-output-per-imputed-data-set"><span class="header-section-number">8.2.2</span> Seperate output per imputed data set</a></li>
  <li><a href="#r-squared" id="toc-r-squared" class="nav-link" data-scroll-target="#r-squared"><span class="header-section-number">8.2.3</span> R-squared</a></li>
  <li><a href="#overall-model-anova" id="toc-overall-model-anova" class="nav-link" data-scroll-target="#overall-model-anova"><span class="header-section-number">8.2.4</span> Overall model ANOVA</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">The <code>mice</code> imputation flow</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="tldr" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> tl;dr</h1>
<section id="generating-imputations" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="generating-imputations"><span class="header-section-number">1.1</span> Generating imputations</h2>
<p>We need the user be able to specify the</p>
<ul>
<li>data</li>
<li>number of imputations</li>
<li>maximum number of iterations</li>
<li>seed</li>
<li>imputation method</li>
<li>the predictor matrix; if relevant with blocks</li>
<li>the visit sequence</li>
</ul>
<p>Later on, we may extend this to formula notation for the imputation models.</p>
</section>
<section id="presentation-of-imputed-data" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="presentation-of-imputed-data"><span class="header-section-number">1.2</span> Presentation of imputed data</h2>
<p>The most conscientious way to export the imputed data is to export both the <code>mids</code> object from <code>mice</code> and present the user with an extracted long format data set. The <code>mids</code> object contains all crucial information about the imputation process and the algorithm. The long format data set mimics the original data, but appends a column indicator for the <span class="math inline">\(m\)</span> imputed data sets.</p>
<ul>
<li>Allow for importing a <code>mids</code> object</li>
<li>Generate a long format data set with said <code>mids</code> object</li>
</ul>
<p>A long format does not lull the user into a false sense of security by assuming that a single imputed data set can be used for analysis.</p>
</section>
<section id="analyzing-imputed-data" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="analyzing-imputed-data"><span class="header-section-number">1.3</span> Analyzing imputed data</h2>
<p>With regression as an example, we need to combine the following JASP output to obtain the pooled estimates <img src="lm_indic.png" class="img-fluid"></p>
<p>More combinations are needed to present the user with the same familiar output as above. This is highlighted in the <a href="#sec-crucial">Section&nbsp;8</a> section. In short, for any output other than the quantity of interest one could choose to:</p>
<ul>
<li>omit the output and only present the pooled estimates and combined inference</li>
<li>aggregate the other output e.g.&nbsp;as follows:
<ul>
<li>normal sampling distribution –&gt; take average and show variance/range</li>
<li>non-normal sampling distribution –&gt; show some proxy of the distribution</li>
</ul></li>
</ul>
<p>Never present users with the separate output of one or more imputed data sets - they may be tempted to use them for analysis. If necessary, these results can be obtained by the user by splitting on the imputation indicator.</p>
</section>
</section>
<section id="introduction-to-mice" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Introduction to <code>mice</code></h1>
<p>Package <code>mice</code> in <span class="proglang">R</span> is a powerful tool for imputing missing data. It is a flexible and easy-to-use package that can handle different types of missing data, including monotone missing data, non-monotone missing data, and missing data in time series. The package is also capable of handling missing data in both continuous and categorical variables.</p>
<p>The <code>mice</code> package is based on the concept of multiple imputation, which is a statistical technique that involves creating multiple imputed datasets, analyzing each dataset separately, and then combining the results to obtain a single set of estimates. This approach has been shown to be more accurate and reliable than other imputation methods, such as mean imputation or listwise deletion and can be seen as a quick approximation of a full Bayesian solution.</p>
<p>The <code>mice</code> package is widely used in a variety of fields, including social science, epidemiology, and public health, and is an essential tool for researchers who need to analyze datasets with missing data. <code>mice</code> has become the de facto standard for multiple imputation in <span class="proglang">R</span> and is widely used in both academia and industry with over 1 million downloads every year from CRAN.</p>
<hr>
</section>
<section id="aim-of-this-flow" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Aim of this flow</h1>
<p>In this flow, we will provide an overview of the <code>mice</code> package and demonstrate how it approaches the stages of imputation, analysis, evaluation and combination.</p>
<hr>
</section>
<section id="imputation" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Imputation</h1>
<p>The <code>mice</code> algorithm is an algorithm to generate multiple imputations by chained equations.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Why multiple imputations?
</div>
</div>
<div class="callout-body-container callout-body">
<p>With imputation, some estimation procedure is used to impute (fill in) each missing datum, resulting in a completed dataset that can be analyzed as if the data were completely observed. We can do this once (single imputation) or multiple times (multiple imputation).</p>
<p>With multiple imputation, each missing datum is imputed <span class="math inline">\(m \geq 2\)</span> times, resulting in <span class="math inline">\(m\)</span> completed datasets. The <span class="math inline">\(m\)</span> completed datasets are then analyzed separately, and the results are combined to yield valid statistical inference.</p>
<p>Multiple imputation (Rubin, 1987) has some benefits over single imputation:</p>
<ul>
<li>it accounts for missing data uncertainty</li>
<li>it accounts for parameter uncertainty</li>
<li>can yield valid inference without additional adjustments</li>
</ul>
</div>
</div>
<p>The <code>mice</code> algorithm was initially designed as a fully conditional specification (FCS) algorithm, which is a type of imputation algorithm that imputes each variable separately, one-by-one, conditional on all other variables in the dataset. The FCS algorithm is based on the idea that imputing each variable separately allows for more flexibility than imputing all variables simultaneously. The rationale behind this thought is that in <code>mice</code>, each incomplete feature in the data can be addressed by a separate imputation model, which can be tailored to the specific characteristics of the feature. An efficient sufficient set of predictors can be chosen for each model, to further optimize the imputation process.</p>
<p>Sometimes, however, it is not desirable to adopt the chained equations approach to imputation. For example, if multiple features in the data obey a specific deterministic relation, then parts of the data should be jointly imputed, instead of separately. Otherwise, the interdepency of features is ignored by the imputation model, which renders the imputation procedure uncongenial with respect to the analysis. To accommodate this, the <code>mice</code> has since deviated from a strictly variable-by-variable architecture and allows for the flexible joint imputation of (blocks of) features. This hybrid approach - where the imputer can assign blocks of features to be jointly imputed, next to other features still being imputed on a variable-by-variable basis - greatly enhances the practical applicability of the <code>mice</code> algorithm. If desired, <code>mice</code> can serve as fully joint imputation method, by specifying the imputation model to be a multivariate model and all features to be imputed as a single joint block.</p>
<hr>
<section id="imputation-procedure" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="imputation-procedure"><span class="header-section-number">4.1</span> Imputation procedure</h2>
<p>Let <span class="math inline">\(Y\)</span> be an incomplete column in the data, with</p>
<ul>
<li><span class="math inline">\(Y_\mathrm{mis}\)</span> denoting the unobserved part;</li>
<li><span class="math inline">\(Y_\mathrm{obs}\)</span> denotes the observed part.</li>
</ul>
<p>Let <span class="math inline">\(X\)</span> be a set of completely observed covariates.</p>
<hr>
<section id="joint-model-imputation" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="joint-model-imputation"><span class="header-section-number">4.1.1</span> Joint model imputation</h3>
<p>With joint modeling, imputations are drawn from an assumed joint multivariate distribution.</p>
<ul>
<li>Often a multivariate normal model is used for both continuous and categorical data,</li>
<li>Other joint models have been proposed (see e.g.&nbsp;Olkin and Tate, 1961; Van Buuren and van Rijckevorsel, 1992; Schafer, 1997; Van Ginkel et al., 2007; Goldstein et al., 2009; Chen et al., 2011).</li>
</ul>
<p>Joint modeling imputations generated under the normal model are usually robust to misspecification of the imputation model (Schafer, 1997; Demirtas et al., 2008), <strong>although transformation towards normality is generally beneficial.</strong></p>
<p>The procedure for joint modeling is as follows:</p>
<ol type="1">
<li>Specify the joint model <span class="math inline">\(P(Y,X)\)</span></li>
<li>Derive <span class="math inline">\(P(Y_\mathrm{mis}|Y_\mathrm{obs},X)\)</span></li>
<li>Draw imputations <span class="math inline">\(\dot Y_\mathrm{mis}\)</span> with a Gibbs sampler</li>
</ol>
<hr>
</section>
<section id="fully-conditional-specification" class="level3" data-number="4.1.2">
<h3 data-number="4.1.2" class="anchored" data-anchor-id="fully-conditional-specification"><span class="header-section-number">4.1.2</span> Fully conditional specification</h3>
<p>Multiple imputation by means of FCS does not start from an explicit multivariate model. With FCS, multivariate missing data is imputed by univariately specifying an imputation model for each incomplete variable, conditional on a set of other (possibly incomplete) variables.</p>
<ul>
<li>the multivariate distribution for the data is thereby implicitly specified through the univariate conditional densities.</li>
<li>imputations are obtained by iterating over the conditionally specified imputation models.</li>
</ul>
<p>The general procedure for fully conditional specification would be to</p>
<ol type="1">
<li>Specify <span class="math inline">\(P(Y^\mathrm{mis} | Y^\mathrm{obs}, X)\)</span></li>
<li>Draw imputations <span class="math inline">\(\dot Y^\mathrm{mis}\)</span> with Gibbs sampler</li>
</ol>
<p>The idea of using conditionally specified models to deal with missing data has been discussed and applied by many authors (see e.g.&nbsp;Kennickell, 1991; Raghunathan and Siscovick, 1996; Oudshoorn et al., 1999; Brand, 1999; Van Buuren et al., 1999; Van Buuren and Oudshoorn, 2000; Raghunathan et al., 2001; Faris et al., 2002; Van Buuren et al., 2006.)</p>
<p>Comparisons between JM and FCS have been made that indicate that FCS is a useful and flexible alternative to JM when the joint distribution of the data is not easily specified (Van Buuren, 2007) and that similar results may be expected from both imputation approaches (Lee and Carlin, 2010).</p>
<p>In <code>mice</code>, the fully conditional specification has been implemented as follows:</p>
<ol type="1">
<li>Specify the imputation models <span class="math inline">\(P(Y_j^\mathrm{mis} | Y_j^\mathrm{obs}, Y_{-j}, X)\)</span>, where <span class="math inline">\(Y_{−j}\)</span> is the set of incomplete variables except <span class="math inline">\(Y_j\)</span></li>
<li>Fill in starting values for the missing data. It does not matter what these values are, as long as they are not missing. Random univariate draws have proven to be computationally convenient without hindering the speed of algorithmic convergence.</li>
<li>Iterate</li>
</ol>
<hr>
</section>
<section id="hybrids-of-jm-and-fcs" class="level3" data-number="4.1.3">
<h3 data-number="4.1.3" class="anchored" data-anchor-id="hybrids-of-jm-and-fcs"><span class="header-section-number">4.1.3</span> Hybrids of JM and FCS</h3>
<p>In <code>mice</code> we can combine the flexibility of FCS with the appealing theoretical properties of joint modeling. In order to do so, we need to partition the variables into <strong>blocks</strong></p>
<ul>
<li><p>For example, we might partition <span class="math inline">\(b\)</span> blocks <span class="math inline">\(h = 1,\dots,b\)</span> as follows</p>
<ul>
<li><p>a single block with <span class="math inline">\(b=1\)</span> would hold a <strong>joint model</strong>: <span class="math display">\[\{Y_1, Y_2, Y_3, Y_4\}, X\]</span></p></li>
<li><p>a quadruple block with <span class="math inline">\(b=4\)</span> would be the conventional fully conditional specification algorithm <span class="math display">\[\{Y_1\},\{Y_2\},\{Y_3\},\{Y_4\}, X\]</span></p></li>
<li><p>anything in between would be a hybrid between the joint model and fully conditional specification. For example, <span class="math display">\[\{Y_1, Y_2, Y_3\},\{Y_4\}, X\]</span></p></li>
</ul></li>
</ul>
<hr>
<section id="why-is-this-useful" class="level4" data-number="4.1.3.1">
<h4 data-number="4.1.3.1" class="anchored" data-anchor-id="why-is-this-useful"><span class="header-section-number">4.1.3.1</span> Why is this useful</h4>
<p>There are many scenarios where a hybrid imputation procedure would be useful. wewill highlight a few:</p>
<ul>
<li><strong>Imputing squares/nonlinear effects</strong>: In the model <span class="math inline">\(y=\alpha + \beta_1X+\beta_2X^2 + \epsilon\)</span>, <span class="math inline">\(X\)</span> and <span class="math inline">\(X^2\)</span> should be imputed jointly (Von Hippel, 2009, Seaman, Bartlett &amp; White, 2012, Vink &amp; Van Buuren, 2013, Bartlett et al., 2015)</li>
<li><strong>Compositional data</strong>: The simplex space in compositional data should be considered as. joint, because the relations between the variables are captured in the ratios. Although some clever subsetting of the problem would allow this to be solved with FCS (Vink, 2015, Ch5), it is better to consider the joint distribution in the following nested composition:</li>
</ul>
<p><span class="math display">\[
\begin{array}{lllllllllllll}
x_0 &amp;=  &amp;x_1        &amp;+  &amp;x_2        &amp;+      &amp;x_3        &amp;+&amp; x_4 &amp;       &amp;   &amp;   &amp;\\
       &amp;    &amp;=      &amp;       &amp;           &amp;       &amp;       &amp;&amp; =        &amp;       &amp;   &amp;   &amp;\\
       &amp;    &amp;x_9        &amp;       &amp;           &amp;       &amp;       &amp;&amp; x_5  &amp;       &amp;   &amp;   &amp;\\
       &amp;    &amp;+      &amp;       &amp;           &amp;       &amp;       &amp;&amp; +        &amp;       &amp;   &amp;   &amp;\\
       &amp;    &amp;x_{10}     &amp;       &amp;           &amp;       &amp;       &amp;&amp;x_6       &amp;=      &amp;x_7    &amp;+&amp;x_8
\end{array}
\]</span></p>
<ul>
<li><strong>Multivariate PMM</strong>: Imputing a combination of outcomes optimally based on a linear combination of covariates (Cai, Vink &amp; Van Buuren, 2023).</li>
</ul>
<hr>
</section>
<section id="nesting-joint-modeling-in-fcs" class="level4" data-number="4.1.3.2">
<h4 data-number="4.1.3.2" class="anchored" data-anchor-id="nesting-joint-modeling-in-fcs"><span class="header-section-number">4.1.3.2</span> Nesting joint modeling in FCS</h4>
<p>The following table details <span class="math inline">\(b=2\)</span> blocks.</p>
<table class="table">
<thead>
<tr class="header">
<th>b</th>
<th>h</th>
<th>target</th>
<th>predictors</th>
<th>type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>1</td>
<td><span class="math inline">\(\{Y_1, Y_2, Y_3\}\)</span></td>
<td><span class="math inline">\(Y_4, X\)</span></td>
<td>multivariate</td>
</tr>
<tr class="even">
<td>2</td>
<td>2</td>
<td><span class="math inline">\(Y_4\)</span></td>
<td><span class="math inline">\(Y_1, Y_2, Y_3, X\)</span></td>
<td>univariate</td>
</tr>
</tbody>
</table>
<p>The first block considers the multivariate imputation of the set <span class="math inline">\((Y_1, Y_2, Y_3)\)</span>. The second block considers the univariate imputation of the remaining column <span class="math inline">\(Y_4\)</span>.</p>
<hr>
</section>
<section id="nesting-fcs-in-fcs" class="level4" data-number="4.1.3.3">
<h4 data-number="4.1.3.3" class="anchored" data-anchor-id="nesting-fcs-in-fcs"><span class="header-section-number">4.1.3.3</span> Nesting FCS in FCS</h4>
<p>With FCS, the scheme on the previous table would take the following embedded structure:</p>
<table class="table">
<thead>
<tr class="header">
<th>b</th>
<th>h</th>
<th>j</th>
<th>target</th>
<th>predictors</th>
<th>type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>1</td>
<td>1</td>
<td><span class="math inline">\(Y_1\)</span></td>
<td><span class="math inline">\(Y_2, Y_3, Y_4, X\)</span></td>
<td>univariate</td>
</tr>
<tr class="even">
<td>2</td>
<td>1</td>
<td>2</td>
<td><span class="math inline">\(Y_2\)</span></td>
<td><span class="math inline">\(Y_1, Y_3, Y_4, X\)</span></td>
<td>univariate</td>
</tr>
<tr class="odd">
<td>2</td>
<td>1</td>
<td>3</td>
<td><span class="math inline">\(Y_3\)</span></td>
<td><span class="math inline">\(Y_1, Y_2, Y_4, X\)</span></td>
<td>univariate</td>
</tr>
<tr class="even">
<td>2</td>
<td>2</td>
<td>1</td>
<td><span class="math inline">\(Y_4\)</span></td>
<td><span class="math inline">\(Y_1, Y_2, Y_3, X\)</span></td>
<td>univariate</td>
</tr>
</tbody>
</table>
<p>The first block is a FCS loop within an FCS imputation procedure.</p>
<hr>
</section>
<section id="benefits-of-blocks-in-mice" class="level4" data-number="4.1.3.4">
<h4 data-number="4.1.3.4" class="anchored" data-anchor-id="benefits-of-blocks-in-mice"><span class="header-section-number">4.1.3.4</span> Benefits of blocks in <code>mice()</code></h4>
<ol type="1">
<li>Looping over <span class="math inline">\(b\)</span> blocks instead of looping over <span class="math inline">\(p\)</span> columns.</li>
<li>Only specify <span class="math inline">\(b \times p\)</span> predictor relations and not <span class="math inline">\(p^2\)</span>.</li>
<li>Only specify <span class="math inline">\(b\)</span> univariate imputation methods instead of <span class="math inline">\(p\)</span> methods.</li>
<li>Ability for imputing more than one column at once</li>
<li>Simplified overall model specification</li>
</ol>
<ul>
<li>e.g.&nbsp;sets of items in scales, matching items in longitudinal data, joining data sets, etc.</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="selecting-predictors" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="selecting-predictors"><span class="header-section-number">4.2</span> Selecting predictors</h2>
<p>Under the conventional FCS predictor specification, we could hypothesize the following <code>predictorMatrix</code>.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>          age item1 item2 sum_items time1 time2 time3 mean_time
age         0     0     0         1     0     0     0         1
item1       1     0     1         0     0     0     0         1
item2       1     1     0         0     0     0     0         1
sum_items   0     1     1         0     0     0     0         0
time1       1     0     0         1     0     1     1         0
time2       1     0     0         1     1     0     1         0
time3       1     0     0         1     1     1     0         0
mean_time   0     0     0         0     1     1     1         0</code></pre>
</div>
</div>
<p>In this predictor matrix, the columns indicate the predictor features and the rows are the target features. The value of 1 indicates that the column is a predictor in the imptutaion model for the row.</p>
<p>Under the outlined hybrid blocked imputation approach, however, we could simplify these specifications into the following blocks and predictor relations.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>blocks <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">age =</span> <span class="st">"age"</span>, </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>               <span class="at">A =</span> <span class="fu">c</span>(<span class="st">"item1"</span>, <span class="st">"item2"</span>, <span class="st">"sum_items"</span>), </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>               <span class="at">B =</span> <span class="fu">c</span>(<span class="st">"time1"</span>, <span class="st">"time2"</span>, <span class="st">"time3"</span>, <span class="st">"mean_time"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>      age item1 item2 sum_items time1 time2 time3 mean_time
age     0     0     0         1     0     0     0         1
Items   1     0     0         0     0     0     0         1
Time    1     0     0         1     0     0     0         0</code></pre>
</div>
</div>
<p>Fully conditionally specified predictor matrices can easily be generated as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>mice<span class="sc">::</span><span class="fu">make.predictorMatrix</span>(mice<span class="sc">::</span>boys)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    age hgt wgt bmi hc gen phb tv reg
age   0   1   1   1  1   1   1  1   1
hgt   1   0   1   1  1   1   1  1   1
wgt   1   1   0   1  1   1   1  1   1
bmi   1   1   1   0  1   1   1  1   1
hc    1   1   1   1  0   1   1  1   1
gen   1   1   1   1  1   0   1  1   1
phb   1   1   1   1  1   1   0  1   1
tv    1   1   1   1  1   1   1  0   1
reg   1   1   1   1  1   1   1  1   0</code></pre>
</div>
</div>
<hr>
</section>
<section id="selecting-an-imputation-method" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="selecting-an-imputation-method"><span class="header-section-number">4.3</span> Selecting an imputation method</h2>
<p>The <code>mice</code> package provides a variety of imputation methods for different types of data. The imputation method can be specified for each imputation model. Default for continuous data is predictive mean matching (PMM), for binary data logistic regression, and for unordered categorical data polytomous regression.</p>
<p>The <code>mice</code> algorithm needs to know which imputation method to use for each variable. The imputation method is specified in the <code>method</code> argument of the <code>mice()</code> function. The <code>method</code> argument is a list that contains the imputation method for each variable in the dataset. The imputation method can be specified as a character string or as a function.</p>
<p>A default <code>method</code> vector can be created as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>mice<span class="sc">::</span><span class="fu">make.method</span>(mice<span class="sc">::</span>boys)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      age       hgt       wgt       bmi        hc       gen       phb        tv 
       ""     "pmm"     "pmm"     "pmm"     "pmm"    "polr"    "polr"     "pmm" 
      reg 
"polyreg" </code></pre>
</div>
</div>
<p><code>age</code> is left intentionally empty because the column is completely observed and needs no imputation.</p>
<hr>
</section>
<section id="determining-the-visit-sequence" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="determining-the-visit-sequence"><span class="header-section-number">4.4</span> Determining the visit sequence</h2>
<p>By default, <code>mice</code> iterates over the columns in a dataset in the order they appear. However, the order in which the columns are imputed can have a significant impact on the quality of the imputations. For example, if a total is updated before the imputation of its components, the imputation of any source the total is dependent on, will be inefficient, or even incorrect.</p>
<p>A default <code>visitSequence</code> can be created as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>mice<span class="sc">::</span><span class="fu">make.visitSequence</span>(mice<span class="sc">::</span>boys)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "age" "hgt" "wgt" "bmi" "hc"  "gen" "phb" "tv"  "reg"</code></pre>
</div>
</div>
<hr>
</section>
</section>
<section id="analysis-of-imputed-data" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Analysis of imputed data</h1>
<p>After the imputation process is complete, the imputed datasets can be analyzed using standard statistical methods. Van Buuren (2020) provides the following schematic overview of the multiple imputation data analysis pipeline.</p>
<p><img src="https://stefvanbuuren.name/fimd/fig/ch01-miflow-1.png" class="img-fluid" style="width:80.0%"></p>
<p>In step 1, we create several <span class="math inline">\(m\)</span> complete versions of the data by replacing the missing values by plausible data values. The task of step 2 is to estimate the parameters of scientific or commercial interest from each imputed dataset. Step 3 involves pooling the <span class="math inline">\(m\)</span> parameter estimates into one estimate, and obtaining an estimate of its variance. The results allow us to arrive at valid decisions from the data, accounting for the missing data and having the correct type I error rate.</p>
<p>These steps relate the following table:</p>
<table class="table">
<colgroup>
<col style="width: 10%">
<col style="width: 9%">
<col style="width: 19%">
<col style="width: 60%">
</colgroup>
<thead>
<tr class="header">
<th>Class</th>
<th>Name</th>
<th>Produced by</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>mids</code></td>
<td><code>imp</code></td>
<td><code>mice::mice()</code></td>
<td>multiply imputed dataset</td>
</tr>
<tr class="even">
<td><code>mild</code></td>
<td><code>idl</code></td>
<td><code>mice::complete()</code></td>
<td>multiply imputed list of data</td>
</tr>
<tr class="odd">
<td><code>mira</code></td>
<td><code>fit</code></td>
<td><code>mice::with()</code></td>
<td>multiple imputation repeated analyses</td>
</tr>
<tr class="even">
<td><code>mipo</code></td>
<td><code>est</code></td>
<td><code>mice::pool()</code></td>
<td>multiple imputation pooled results</td>
</tr>
</tbody>
</table>
<p>A standard workflow to generate 5 imputations with <code>mice</code> and giving the algorithm 10 iterations would be:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(magrittr)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(purrr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'purrr'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked from 'package:magrittr':

    set_names</code></pre>
</div>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mice)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'mice'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked from 'package:stats':

    filter</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following objects are masked from 'package:base':

    cbind, rbind</code></pre>
</div>
</div>
<div class="cell" data-hash="mice_flow_cache/html/generateimps_54223b78c7cd064bac2e573865f6ccb7">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>meth <span class="ot">&lt;-</span> <span class="fu">make.method</span>(boys)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">&lt;-</span> <span class="fu">make.predictorMatrix</span>(boys)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>vis  <span class="ot">&lt;-</span> <span class="fu">make.visitSequence</span>(boys)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>imp <span class="ot">&lt;-</span> <span class="fu">mice</span>(boys, <span class="at">m =</span> <span class="dv">5</span>, <span class="at">maxit =</span> <span class="dv">10</span>, </span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>            <span class="at">method =</span> meth, </span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>            <span class="at">predictorMatrix =</span> pred, </span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>            <span class="at">visitSequence =</span> vis, </span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>            <span class="at">seed =</span> <span class="dv">123</span>) <span class="co"># for reproducibility</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
 iter imp variable
  1   1  hgt  wgt  bmi  hc  gen  phb  tv  reg
  1   2  hgt  wgt  bmi  hc  gen  phb  tv  reg
  1   3  hgt  wgt  bmi  hc  gen  phb  tv  reg
  1   4  hgt  wgt  bmi  hc  gen  phb  tv  reg
  1   5  hgt  wgt  bmi  hc  gen  phb  tv  reg
  2   1  hgt  wgt  bmi  hc  gen  phb  tv  reg
  2   2  hgt  wgt  bmi  hc  gen  phb  tv  reg
  2   3  hgt  wgt  bmi  hc  gen  phb  tv  reg
  2   4  hgt  wgt  bmi  hc  gen  phb  tv  reg
  2   5  hgt  wgt  bmi  hc  gen  phb  tv  reg
  3   1  hgt  wgt  bmi  hc  gen  phb  tv  reg
  3   2  hgt  wgt  bmi  hc  gen  phb  tv  reg
  3   3  hgt  wgt  bmi  hc  gen  phb  tv  reg
  3   4  hgt  wgt  bmi  hc  gen  phb  tv  reg
  3   5  hgt  wgt  bmi  hc  gen  phb  tv  reg
  4   1  hgt  wgt  bmi  hc  gen  phb  tv  reg
  4   2  hgt  wgt  bmi  hc  gen  phb  tv  reg
  4   3  hgt  wgt  bmi  hc  gen  phb  tv  reg
  4   4  hgt  wgt  bmi  hc  gen  phb  tv  reg
  4   5  hgt  wgt  bmi  hc  gen  phb  tv  reg
  5   1  hgt  wgt  bmi  hc  gen  phb  tv  reg
  5   2  hgt  wgt  bmi  hc  gen  phb  tv  reg
  5   3  hgt  wgt  bmi  hc  gen  phb  tv  reg
  5   4  hgt  wgt  bmi  hc  gen  phb  tv  reg
  5   5  hgt  wgt  bmi  hc  gen  phb  tv  reg
  6   1  hgt  wgt  bmi  hc  gen  phb  tv  reg
  6   2  hgt  wgt  bmi  hc  gen  phb  tv  reg
  6   3  hgt  wgt  bmi  hc  gen  phb  tv  reg
  6   4  hgt  wgt  bmi  hc  gen  phb  tv  reg
  6   5  hgt  wgt  bmi  hc  gen  phb  tv  reg
  7   1  hgt  wgt  bmi  hc  gen  phb  tv  reg
  7   2  hgt  wgt  bmi  hc  gen  phb  tv  reg
  7   3  hgt  wgt  bmi  hc  gen  phb  tv  reg
  7   4  hgt  wgt  bmi  hc  gen  phb  tv  reg
  7   5  hgt  wgt  bmi  hc  gen  phb  tv  reg
  8   1  hgt  wgt  bmi  hc  gen  phb  tv  reg
  8   2  hgt  wgt  bmi  hc  gen  phb  tv  reg
  8   3  hgt  wgt  bmi  hc  gen  phb  tv  reg
  8   4  hgt  wgt  bmi  hc  gen  phb  tv  reg
  8   5  hgt  wgt  bmi  hc  gen  phb  tv  reg
  9   1  hgt  wgt  bmi  hc  gen  phb  tv  reg
  9   2  hgt  wgt  bmi  hc  gen  phb  tv  reg
  9   3  hgt  wgt  bmi  hc  gen  phb  tv  reg
  9   4  hgt  wgt  bmi  hc  gen  phb  tv  reg
  9   5  hgt  wgt  bmi  hc  gen  phb  tv  reg
  10   1  hgt  wgt  bmi  hc  gen  phb  tv  reg
  10   2  hgt  wgt  bmi  hc  gen  phb  tv  reg
  10   3  hgt  wgt  bmi  hc  gen  phb  tv  reg
  10   4  hgt  wgt  bmi  hc  gen  phb  tv  reg
  10   5  hgt  wgt  bmi  hc  gen  phb  tv  reg</code></pre>
</div>
</div>
<p>Then, if we fit the model <code>age ~ height + weight</code> on each imputed dataset, we would use the following code:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">with</span>(imp, <span class="fu">lm</span>(age <span class="sc">~</span> hgt <span class="sc">+</span> wgt)) <span class="co"># obtain </span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>fit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>call :
with.mids(data = imp, expr = lm(age ~ hgt + wgt))

call1 :
mice(data = boys, m = 5, method = meth, predictorMatrix = pred, 
    visitSequence = vis, maxit = 10, seed = 123)

nmis :
age hgt wgt bmi  hc gen phb  tv reg 
  0  20   4  21  46 503 503 522   3 

analyses :
[[1]]

Call:
lm(formula = age ~ hgt + wgt)

Coefficients:
(Intercept)          hgt          wgt  
   -7.48938      0.10641      0.07249  


[[2]]

Call:
lm(formula = age ~ hgt + wgt)

Coefficients:
(Intercept)          hgt          wgt  
   -7.45877      0.10622      0.07248  


[[3]]

Call:
lm(formula = age ~ hgt + wgt)

Coefficients:
(Intercept)          hgt          wgt  
    -7.4487       0.1060       0.0729  


[[4]]

Call:
lm(formula = age ~ hgt + wgt)

Coefficients:
(Intercept)          hgt          wgt  
   -7.40083      0.10558      0.07344  


[[5]]

Call:
lm(formula = age ~ hgt + wgt)

Coefficients:
(Intercept)          hgt          wgt  
   -7.44715      0.10605      0.07271  </code></pre>
</div>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">class</span>(fit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "mira"   "matrix"</code></pre>
</div>
</div>
<p>or the following pipe</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>fit_2 <span class="ot">&lt;-</span> imp <span class="sc">|&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">complete</span>(<span class="st">"all"</span>) <span class="sc">|&gt;</span> <span class="co"># obtain object of class mild</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span>(<span class="sc">~</span>.x <span class="sc">%$%</span> <span class="fu">lm</span>(age <span class="sc">~</span> hgt <span class="sc">+</span> wgt)) <span class="co"># obtain object of class mira for each idl</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>fit_2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$`1`

Call:
lm(formula = age ~ hgt + wgt)

Coefficients:
(Intercept)          hgt          wgt  
   -7.48938      0.10641      0.07249  


$`2`

Call:
lm(formula = age ~ hgt + wgt)

Coefficients:
(Intercept)          hgt          wgt  
   -7.45877      0.10622      0.07248  


$`3`

Call:
lm(formula = age ~ hgt + wgt)

Coefficients:
(Intercept)          hgt          wgt  
    -7.4487       0.1060       0.0729  


$`4`

Call:
lm(formula = age ~ hgt + wgt)

Coefficients:
(Intercept)          hgt          wgt  
   -7.40083      0.10558      0.07344  


$`5`

Call:
lm(formula = age ~ hgt + wgt)

Coefficients:
(Intercept)          hgt          wgt  
   -7.44715      0.10605      0.07271  </code></pre>
</div>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">class</span>(fit_2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "list"</code></pre>
</div>
</div>
<p>Pooling the model parameters happens by default conform the combination rules proposed by Rubin (1987, p76). Rubin defined <span class="math inline">\(Q\)</span> as the quantity of interest (possibly a vector) and <span class="math inline">\(U\)</span> as its variance. With multiple imputation, <span class="math inline">\(m\)</span> complete data estimates can be averaged as <span class="math display">\[\bar{Q}=\frac{1}{m}\sum^{m}_{l=1}{ \hat{Q}}_{l},\]</span></p>
<p>where <span class="math inline">\(\hat Q_l\)</span> is an estimate of <span class="math inline">\(Q\)</span> from the <span class="math inline">\(l\)</span>-th imputed data set. Let <span class="math inline">\(\bar U_l\)</span> be the estimated variance-covariance matrix of <span class="math inline">\(\hat Q_l\)</span>. The complete data variances of <span class="math inline">\(Q\)</span> can be combined by</p>
<p><span class="math display">\[\bar{U}=\frac{1}{m}\sum^{m}_{l=1}{ {\bar U}}_{l}.\]</span> The variance between the complete data estimates can be calculated as</p>
<p><span class="math display">\[B=\frac{1}{m-1}\sum^{m}_{l=1}(\hat{ Q}_l-\bar{Q})^\prime(\hat{ Q}_l-\bar{Q}).\]</span></p>
<p>The total variance of <span class="math inline">\(({ Q}-\bar{Q})\)</span> is then defined as</p>
<p><span class="math display">\[T=\bar{U}+B+B/m.\]</span></p>
<p>Obtaining the pooled estimates from either workflow is then straightforward with the <code>mice::pool()</code> function</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pool</span>(fit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Class: mipo    m = 5 
         term m    estimate         ubar            b            t dfcom
1 (Intercept) 5 -7.44895766 5.796089e-02 1.012437e-03 5.917582e-02   745
2         hgt 5  0.10605533 1.070342e-05 9.690545e-08 1.081971e-05   745
3         wgt 5  0.07280384 3.421076e-05 1.556045e-07 3.439749e-05   745
        df        riv      lambda         fmi
1 675.9179 0.02096111 0.020530763 0.023416147
2 719.7451 0.01086443 0.010747662 0.013485148
3 734.9734 0.00545809 0.005428461 0.008123874</code></pre>
</div>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pool</span>(fit_2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Class: mipo    m = 5 
         term m    estimate         ubar            b            t dfcom
1 (Intercept) 5 -7.44895766 5.796089e-02 1.012437e-03 5.917582e-02   745
2         hgt 5  0.10605533 1.070342e-05 9.690545e-08 1.081971e-05   745
3         wgt 5  0.07280384 3.421076e-05 1.556045e-07 3.439749e-05   745
        df        riv      lambda         fmi
1 675.9179 0.02096111 0.020530763 0.023416147
2 719.7451 0.01086443 0.010747662 0.013485148
3 734.9734 0.00545809 0.005428461 0.008123874</code></pre>
</div>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">class</span>(fit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "mira"   "matrix"</code></pre>
</div>
</div>
<p>and a <code>mice::summary.mipo()</code> is available to obtain statistical tests and confidence intervals.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>fit <span class="sc">|&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pool</span>() <span class="sc">|&gt;</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>(<span class="at">conf.int =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         term    estimate   std.error statistic       df       p.value
1 (Intercept) -7.44895766 0.243260806 -30.62128 675.9179 7.774115e-130
2         hgt  0.10605533 0.003289332  32.24221 719.7451 7.907088e-142
3         wgt  0.07280384 0.005864937  12.41341 734.9734  2.945329e-32
        2.5 %      97.5 %
1 -7.92659536 -6.97131997
2  0.09959750  0.11251317
3  0.06128982  0.08431787</code></pre>
</div>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>fit_2 <span class="sc">|&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pool</span>() <span class="sc">|&gt;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>(<span class="at">conf.int =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         term    estimate   std.error statistic       df       p.value
1 (Intercept) -7.44895766 0.243260806 -30.62128 675.9179 7.774115e-130
2         hgt  0.10605533 0.003289332  32.24221 719.7451 7.907088e-142
3         wgt  0.07280384 0.005864937  12.41341 734.9734  2.945329e-32
        2.5 %      97.5 %
1 -7.92659536 -6.97131997
2  0.09959750  0.11251317
3  0.06128982  0.08431787</code></pre>
</div>
</div>
</section>
<section id="evaluation-of-algorithmic-convergence" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Evaluation of algorithmic convergence</h1>
<p>The <code>mice</code> algorithm is an iterative algorithm that generates imputations by iteratively cycling over the incomplete variables in the dataset, where every iteration would represent a new cycle according to the <code>visitSequence</code>. The algorithm stops when the maximum number of iterations <code>maxit</code> is reached. At this point, the algorithm may not have converged and closer inspection is needed. <code>mice</code> provides a <code>mice::plot()</code> function to generate trace plots based on the means and variances of the multiple chains in an object of class <code>mids</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(imp)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mice_flow_files/figure-html/unnamed-chunk-11-1.png" class="img-fluid" width="672"></p>
</div>
<div class="cell-output-display">
<p><img src="mice_flow_files/figure-html/unnamed-chunk-11-2.png" class="img-fluid" width="672"></p>
</div>
<div class="cell-output-display">
<p><img src="mice_flow_files/figure-html/unnamed-chunk-11-3.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>As you can see, convergence is not optimal here because the deterministic relation between <code>wgt</code>, <code>hgt</code> and <code>bmi</code> is not jointly considered. But that is not the focus of this document, so we ignore the nonconvergence for now.</p>
</section>
<section id="evaluation-of-the-imputations" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Evaluation of the imputations</h1>
<p>The imputations can be evaluated using a variety of methods, including graphical methods, statistical tests, and comparisons with other imputation methods. The <code>mice</code> package provides a variety of functions for evaluating the imputed and the incomplete data, including <code>mice::densityplot()</code>, <code>mice::xyplot()</code>, <code>mice::stripplot()</code>, <code>mice::bwplot()</code>, <code>mice::fluxplot()</code>, <code>mice::md.pattern()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">densityplot</span>(imp)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mice_flow_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">xyplot</span>(imp, age <span class="sc">~</span> tv)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mice_flow_files/figure-html/unnamed-chunk-12-2.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="fu">stripplot</span>(imp)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mice_flow_files/figure-html/unnamed-chunk-12-3.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">bwplot</span>(imp)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mice_flow_files/figure-html/unnamed-chunk-12-4.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fluxplot</span>(boys)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mice_flow_files/figure-html/unnamed-chunk-12-5.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">md.pattern</span>(boys)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mice_flow_files/figure-html/unnamed-chunk-12-6.png" class="img-fluid" width="672"></p>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>    age reg wgt hgt bmi hc gen phb  tv     
223   1   1   1   1   1  1   1   1   1    0
19    1   1   1   1   1  1   1   1   0    1
1     1   1   1   1   1  1   1   0   1    1
1     1   1   1   1   1  1   0   1   0    2
437   1   1   1   1   1  1   0   0   0    3
43    1   1   1   1   1  0   0   0   0    4
16    1   1   1   0   0  1   0   0   0    5
1     1   1   1   0   0  0   0   0   0    6
1     1   1   0   1   0  1   0   0   0    5
1     1   1   0   0   0  1   1   1   1    3
1     1   1   0   0   0  0   1   1   1    4
1     1   1   0   0   0  0   0   0   0    7
3     1   0   1   1   1  1   0   0   0    4
      0   3   4  20  21 46 503 503 522 1622</code></pre>
</div>
</div>
<p>A similar but more flexible ‘Grammar of Graphics’ approach can be obtained by <a href="https://cran.r-project.org/web/packages/ggmice/vignettes/ggmice.html">the <code>ggmice</code> package.</a>. But I’ll leave that out for now.</p>
</section>
<section id="sec-crucial" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> What JASP output is crucial?</h1>
<p>Based on the above outline of the procedure and the standard (i.e.&nbsp;minimum) set of evaluations and plots to be available, the following JASP output is needed to perform the pooling steps:</p>
<section id="linear-regression" class="level2" data-number="8.1">
<h2 data-number="8.1" class="anchored" data-anchor-id="linear-regression"><span class="header-section-number">8.1</span> Linear regression</h2>
<p>Take the following output from JASP as an example. <img src="lm.png" class="img-fluid"> With <code>R</code> we would do the following:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"Album Sales.jasp.csv"</span>)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>data <span class="sc">%$%</span> </span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lm</span>(sales <span class="sc">~</span> airplay) <span class="sc">%&gt;%</span> </span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  summary</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = sales ~ airplay)

Residuals:
     Min       1Q   Median       3Q      Max 
-173.649  -47.894    1.496   39.072  145.432 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  84.8725    11.2670   7.533 1.73e-12 ***
airplay       3.9392     0.3743  10.524  &lt; 2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 64.79 on 198 degrees of freedom
Multiple R-squared:  0.3587,    Adjusted R-squared:  0.3555 
F-statistic: 110.7 on 1 and 198 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
</div>
</section>
<section id="pooling-regression-output" class="level2" data-number="8.2">
<h2 data-number="8.2" class="anchored" data-anchor-id="pooling-regression-output"><span class="header-section-number">8.2</span> Pooling regression output</h2>
<section id="coefficients-and-their-tests" class="level3" data-number="8.2.1">
<h3 data-number="8.2.1" class="anchored" data-anchor-id="coefficients-and-their-tests"><span class="header-section-number">8.2.1</span> Coefficients and their tests</h3>
<p>To illustrate the <code>mice</code> workflow, we induce some missingness in the data with <code>mice::ampute()</code>. In <code>mice</code> we would do the following:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>imp <span class="ot">&lt;-</span> <span class="fu">ampute</span>(data)<span class="sc">$</span>amp <span class="sc">|&gt;</span> <span class="co"># make some missings because there are none</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mice</span>(<span class="at">printFlag=</span><span class="cn">FALSE</span>)    <span class="co"># impute, but omit iteration history printing</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>idl <span class="ot">&lt;-</span> imp <span class="sc">|&gt;</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">complete</span>(<span class="st">"all"</span>) <span class="co"># obtain object of class mild</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>idl <span class="sc">|&gt;</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span>(<span class="sc">~</span>.x <span class="sc">%$%</span> <span class="fu">lm</span>(sales <span class="sc">~</span> airplay)) <span class="sc">|&gt;</span> <span class="co"># run the model on each imputed dataset</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pool</span>() <span class="sc">%&gt;%</span>  <span class="co"># pool the results</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>(<span class="at">conf.int =</span> <span class="cn">TRUE</span>) <span class="co"># obtain the combined inference</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         term  estimate  std.error statistic        df      p.value     2.5 %
1 (Intercept) 87.412824 11.9656311  7.305325  86.36787 1.289424e-10 63.627382
2     airplay  3.818986  0.3818029 10.002505 123.39576 1.304828e-17  3.063254
      97.5 %
1 111.198266
2   4.574717</code></pre>
</div>
</div>
<p>This yields part of the standard SPSS output. The pooled estimates are based on the combination of the following model output by means of Rubin’s rules.</p>
</section>
<section id="seperate-output-per-imputed-data-set" class="level3" data-number="8.2.2">
<h3 data-number="8.2.2" class="anchored" data-anchor-id="seperate-output-per-imputed-data-set"><span class="header-section-number">8.2.2</span> Seperate output per imputed data set</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>idl <span class="sc">|&gt;</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span>(<span class="sc">~</span>.x <span class="sc">%$%</span> <span class="fu">lm</span>(sales <span class="sc">~</span> airplay) <span class="sc">%&gt;%</span> <span class="fu">summary</span>(<span class="at">conf.int =</span> <span class="cn">TRUE</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$`1`

Call:
lm(formula = sales ~ airplay)

Residuals:
     Min       1Q   Median       3Q      Max 
-169.220  -47.316    0.615   49.464  168.827 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  94.4186    11.2360   8.403 8.38e-15 ***
airplay       3.6755     0.3755   9.789  &lt; 2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 66.52 on 198 degrees of freedom
Multiple R-squared:  0.3261,    Adjusted R-squared:  0.3227 
F-statistic: 95.82 on 1 and 198 DF,  p-value: &lt; 2.2e-16


$`2`

Call:
lm(formula = sales ~ airplay)

Residuals:
     Min       1Q   Median       3Q      Max 
-170.681  -47.182    4.067   41.651  143.315 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  87.5187    10.9381   8.001 1.02e-13 ***
airplay       3.8333     0.3598  10.653  &lt; 2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 63.7 on 198 degrees of freedom
Multiple R-squared:  0.3643,    Adjusted R-squared:  0.3611 
F-statistic: 113.5 on 1 and 198 DF,  p-value: &lt; 2.2e-16


$`3`

Call:
lm(formula = sales ~ airplay)

Residuals:
     Min       1Q   Median       3Q      Max 
-166.856  -47.604    3.525   38.292  167.869 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  86.8452    11.1913    7.76 4.42e-13 ***
airplay       3.7738     0.3665   10.30  &lt; 2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 65.67 on 198 degrees of freedom
Multiple R-squared:  0.3488,    Adjusted R-squared:  0.3455 
F-statistic:   106 on 1 and 198 DF,  p-value: &lt; 2.2e-16


$`4`

Call:
lm(formula = sales ~ airplay)

Residuals:
     Min       1Q   Median       3Q      Max 
-175.406  -46.785    2.935   46.767  183.900 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)   84.632     10.972   7.713 5.86e-13 ***
airplay        3.977      0.360  11.048  &lt; 2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 64.31 on 198 degrees of freedom
Multiple R-squared:  0.3814,    Adjusted R-squared:  0.3782 
F-statistic: 122.1 on 1 and 198 DF,  p-value: &lt; 2.2e-16


$`5`

Call:
lm(formula = sales ~ airplay)

Residuals:
     Min       1Q   Median       3Q      Max 
-166.933  -44.401    5.462   38.955  147.173 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)   83.650     10.835    7.72 5.62e-13 ***
airplay        3.836      0.350   10.96  &lt; 2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 63.15 on 198 degrees of freedom
Multiple R-squared:  0.3776,    Adjusted R-squared:  0.3745 
F-statistic: 120.1 on 1 and 198 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
</div>
</section>
<section id="r-squared" class="level3" data-number="8.2.3">
<h3 data-number="8.2.3" class="anchored" data-anchor-id="r-squared"><span class="header-section-number">8.2.3</span> R-squared</h3>
<p>We can grab any necessary values from the <code>mice</code> imputations as follows. For example, to obtain the <span class="math inline">\(R^2\)</span> values for each imputed dataset, we would do the following:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>idl <span class="sc">|&gt;</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span>(<span class="sc">~</span>.x <span class="sc">%$%</span> <span class="fu">lm</span>(sales <span class="sc">~</span> airplay) <span class="sc">%&gt;%</span> summary) <span class="sc">|&gt;</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map_dbl</span>(<span class="sc">~</span>.<span class="sc">$</span>r.squared)  <span class="co"># Extract R^2 for each model</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        1         2         3         4         5 
0.3261084 0.3643297 0.3487738 0.3813636 0.3775998 </code></pre>
</div>
</div>
<p>Pooling <span class="math inline">\(R^2\)</span> values isn’t directly supported by most statistical methodologies because is a measure of model fit rather than a parameter estimate. However, we could consider reporting the range, mean, or median of these values as a descriptive statistic of how the models perform across the imputed datasets. I believe Joost van Ginkel (LeidenUniv) has some methodological evaluations about combination approaches for <span class="math inline">\(R^2\)</span> values.</p>
</section>
<section id="overall-model-anova" class="level3" data-number="8.2.4">
<h3 data-number="8.2.4" class="anchored" data-anchor-id="overall-model-anova"><span class="header-section-number">8.2.4</span> Overall model ANOVA</h3>
<p>Obtaining an estimate of the pooled ANOVA could be done as follows, by comparing the full model to the nested <em>empty</em> model.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Needs to use the with() workflow</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>fit1 <span class="ot">&lt;-</span> <span class="fu">with</span>(imp, <span class="fu">lm</span>(sales <span class="sc">~</span> <span class="dv">1</span>)) <span class="co"># intercept only</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>fit2 <span class="ot">&lt;-</span> <span class="fu">with</span>(imp, <span class="fu">lm</span>(sales <span class="sc">~</span> airplay)) <span class="co"># intercept and airplay</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="fu">D1</span>(fit2, fit1) <span class="co"># multivariate Wald test</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   test statistic df1 df2 dfcom      p.value       riv
 1 ~~ 2  100.0501   1   4   198 0.0005614589 0.1097006</code></pre>
</div>
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="fu">D2</span>(fit2, fit1) <span class="co"># combining test statistic (least assumptions AND power)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   test statistic df1      df2 dfcom      p.value       riv
 1 ~~ 2  84.04016   1 67.71985    NA 1.747871e-13 0.3210682</code></pre>
</div>
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="fu">D3</span>(fit2, fit1) <span class="co"># likelihood-ratio test</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   test statistic df1      df2 dfcom     p.value       riv
 1 ~~ 2  80.45968   1 419.1569   198 9.98403e-18 0.1082642</code></pre>
</div>
</div>
<p>There are also other ways of combining the ANOVA, such as multiplying the <span class="math inline">\(m\)</span> F-statistics with their degrees of freedom, and then pooling according an approximation of the <span class="math inline">\(\chi^2\)</span> distribution (see e.g.&nbsp;<a href="https://cran.r-project.org/web/packages/miceadds/miceadds.pdf">the miceadds::micombine.F function</a>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(miceadds)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>* miceadds 3.17-44 (2024-01-08 19:08:24)</code></pre>
</div>
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>Fs <span class="ot">&lt;-</span> idl <span class="sc">|&gt;</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span>(<span class="sc">~</span>.x <span class="sc">%$%</span> <span class="fu">anova</span>(<span class="fu">lm</span>(sales <span class="sc">~</span> airplay))) <span class="sc">|&gt;</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map_dbl</span>(<span class="sc">~</span>.<span class="sc">$</span>F[<span class="dv">1</span>])</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>dfs <span class="ot">&lt;-</span> idl <span class="sc">|&gt;</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span>(<span class="sc">~</span>.x <span class="sc">%$%</span> <span class="fu">anova</span>(<span class="fu">lm</span>(sales <span class="sc">~</span> airplay))) <span class="sc">|&gt;</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map_dbl</span>(<span class="sc">~</span>.<span class="sc">$</span>Df[<span class="dv">1</span>])</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>miceadds<span class="sc">::</span><span class="fu">micombine.F</span>(Fs, <span class="fu">median</span>(dfs))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Combination of Chi Square Statistics for Multiply Imputed Data
Using 5 Imputed Data Sets
F(1, 67.72)=84.04     p=0 </code></pre>
</div>
</div>
<p>which is equivalent to the D2-statistic in the above model-comparison outline.</p>
<p>Also relevant: <a href="https://doi.org/10.1027/1614-2241/a000111">https://doi.org/10.1027/1614-2241/a000111</a></p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>